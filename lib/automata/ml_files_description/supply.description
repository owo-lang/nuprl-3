%-------------------------------------------------------------------------------+
|  Supply.ml:            ML-functions for general use in PRL                    |
+-------------------------------------------------------------------------------%



% **************** LIST OF USED PREDEFINED FUNCTIONS  ***************************
*                                                                               *      
*     map          :  (* -> **)#(*list) -> (**list)                             *
*     ^            :  tok -> tok -> tok                (infix concat)           * 
*     match                                                                     *
*                                                                               *         
******************** END LIST OF PREDEFINED FUNCTIONS **************************%      




   basic term definitions 
   ----------------------      

    INT   : term        -  short for "make_int_term"
    NIL   : term        -  short for "make_nil_term"  
    VOID  : term        -  short for "make_void_term" 
    mvar  : tok -> term -  short for "make_var_term" 
    imp   : dummy_term
    andl  : dummy_term
    andr  : dummy_term
    zero  : term        - PRL 0
    one   : term        - PRL 1
    U1    : term        - PRL U1
    U2    : term        - PRL U2


   helpfunctions
   -------------

   cat      : tok -> int -> tok                 concats token and integer to a token   

   is_member: * -> *list -> bool                checks if an element is in a list 

   ids      : declaration_list -> tok_list      creates list of identifiers of the dec_list 

   cut_from : int -> * list -> * list           i [a1;..an] -> [a1,..ai]

   cut_first: int -> * list -> * list           i [a1;..an] -> [ai,..an]

   is_alpha_convertible : term -> term -> bool

   list     : int -> * -> * list                n a  -> [a;a;a;..]

   intlist  : int -> int -> int list            n x ->  [x;x+1;...x+n-1]

   first_exp: proof -> term                     if conclusion is a=b in T return a

   ordered_equality : int -> proof -> (term#term#term)
      if conclusion is a=b in T return a,b,T for no = 1  b,a,T otherwise

   new      : tok -> proof -> tok
      returns a new identifier for the proof which starts with the given token
      does not check simultaneous calls (should be faster than new_id)
      In that case use different tokens to distinguish
      (FUTURE IMPROVEMENT: HAS TO CHECK IF VAR OCCURS IN CONCLUSION )
   



   TYPE INFORMATION FUNCTIONS 
   --------------------------
      try to find the type of a given expression using the informations given in a proof

  
   hyp_info: tok -> proof -> int#term
      returns hypothesis number and type if var is mentioned in declaration list
      fails otherwise

   typed: term -> declaration -> term;
      returns type of an expression if mentioned in declaration - fails otherwise

   typeof : term -> proof -> (term -> proof -> term) -> term
   type_of: term -> proof -> term

      typeof returns the type of an expression using special_type_information (first),
      information from the hypotheses of the proof and information from the structure 
      of the expression.
      special_type_information must fail if it does not succeed
      default is (\exp.\proof. fail) as in type_of 

      ( IMPROVEMENTS according to Dougs get_type function should be done some day)



   MATCHING
   --------

   match_subterms    :  term -> term -> proof -> term list
      matches a term s against subterms of a given term t and returns an instantiation list
      for variables in t. Tries to find additional information on instances in the given
      proof if instance_list is incompe.
      EXAMPLE: t = (x1:A1 -> A2 -> ( (x3:A3 -> B & B') # (y3:C3 ->C4) )
               s = B'[a1,a3/x1,x3]
      returns  a1.imp.andl.a3.andr
   
      Needs a lot of helpfunctions and lists

      match_list  [...(xi,ai)..]    generated by match, maybe unordered or incomplete
      elim_list   [...(xi,Ai)..]    generated during decomposition of t, ordered
                                    during build (a helpfunction)
                                    complete from the i-th element
      inst_list   ai.ai+1.....      instances for the xi (resp. imp, andl, andr) found 
                                    in match_list or otherwise
                                    ordered and complete from the i-th element

   ( MATCHING doesn't seem to work correct when products appear --- CHECK)
   ( should be extended to permutation of equalities/ all_quantifiers etc.)

%  ************************************************************************************   %