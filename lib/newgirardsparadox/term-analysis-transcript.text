-*- Mode: Text; hardcopy-fonts: fix8 -*-
	
October 28, 1986.  Author: Doug Howe.



	In this file is a transcript of the ML computations which were
done as part of the argument presented in my paper "The Computational
Behaviour of Girard's Paradox".  The ML functions used are either
primitive, defined in the tactic collection that goes with the library,
or are defined within ML objects in the library itself.  ML objects
which are particular to Girard's paradox are in the library.

	The transcript was generated by the ML-dribble utility, which
can be obtained by loading in the file nuprl:sys;ml;ml-dribble (if the
file is not there, then the utility has been incorporated into the prl
system).  Dribbling is started by calling the (lisp) function
start-ml-dribble with a file-name argument, and is ended by calling
end-ml-dribble.  The actual interaction with ML that was generated has
been editted; errors have been removed, but what is left is a sequence
of evaluations which would proceed exactly as shown if redone.  The
lines which are part of the transcript begin with "M> "; everything else
is commentary.

	Before giving the transcript, we need to make a few points about
some of the details of interaction.  First, because of the sheer size of
some of the terms dealt with (and the concomitant amount of time that
the grossly inefficient display mechanism takes to process the terms),
the display of many results of intermediate computations were
suppressed.  (This was done by inserting a hack in the definition of the
function ml-print_term which allowed toggling of term-display.)  Second,
the function used for all computations was lambda_compute, (whose LISP
code lives in nuprl:sys;prl;ref-rules-comp), which allows one to specify
whether the term is to be normalized or head-normalized, and which
term_of terms are to be considered unexpandable constants.  (The
"lambda" in the name comes from the fact that this symbolic computation
function is only partially implemented.)  Third, the variable '_' was
used in place of the special variable mentioned in the paper.  Fourth,
the function bag_types was used to replace by '_' any subterm which was
explicitly a type.  Fifth, for visual formatting of computation results,
the function fixup was used to replace instances of pairing and
projection by the defined forms given in the paper (using Nuprl's
pairing constructor).  Finally, there are some name differences between
the terms in the library and the terms presented in the paper.  In
particular, the assumed type is "A" in the library (instead of "T"), and
the variable "y" of wf in the paper is actually "v24".


First, a few short forms.

M> let an = almost_normalize;;
M> an = - : (term -> term)
M> let pn = partially_normalize;;
M> pn = - : (term -> term)
M> let hn t = lambda_compute t false true [];;
M> hn = - : (term -> term)
M> let ext = extracted_term_of_theorem;;
M> ext = - : (tok -> term)
M> let un_ap = decompose_application;;
M> un_ap = - : (term -> term list)

Now we simplify all the extractions, and print out wf.

M> (rev o firstn 11 o filter (\x. object_kind x = `THM`) o rev o library) ();;  
M> [`eq_sym`;
M>  `eq_lemma`;
M>  `embedding_lemma`;
M>  `dU_implies_trans`;
M>  `dU_implies_wf`;
M>  `Uord_trans`;
M>  `Uord_wf`;
M>  `Uord_in_dU`;
M>  `Rb_in_dU`;
M>  `Uord_max`;
M>  `contradiction`]
M> : tok list
M> adjust_extractions pn;;
M> [(); (); (); (); (); (); (); (); (); (); ()] : void list
M> pretty_print_term_to_file (ext `Uord_wf`, `Nuprl:Libraries;NewGirardsParadox;wf.text`);; 
M> () : void


Now we start examining the "first iteration" of the looping combinator.
We first do the unfolding of YF.

M> let [F;r] = (un_ap o hn o ext) `contradiction`;;
M> F =  : term
M> r =  : term
M> destruct_token F;;
M> `F` : tok
M> let [wf;();t] = (un_ap o hr_until `Uord_wf`) r;;
M> wf =  : term
M> t =  : term
M> destruct_term_of_theorem wf;;
M> `Uord_wf` : tok

We now deal with p10.

M> let [t2;f1] = destruct_tuple (pn t);;
M> t2 =  : term
M> f1 =  : term
M> let [();p10;d] = (destruct_tuple o an) t2;;
M> p10 =  : term
M> d =  : term
M> destruct_term_of_theorem d;;
M> `Uord_in_dU` : tok

M> let [();();();();eq;();();op0;bpf0] = destruct_tuple p10;;
M> eq =  : term
M> op0 =  : term
M> bpf0 =  : term
M> eq;;
M> \P.(\v23.v23) : term
M> let [op0;bpf0;f1] = map bag_types [op0;bpf0;f1];;
M> op0 =  : term
M> bpf0 =  : term
M> f1 =  : term

M> (destruct_real_tuple o fixup o an o make_ap)
M> [op0;'_';'_';'_';'_';'sj'];; 
M> [_;
M>  \u.(\v._);
M>  \z._;
M>  _;
M>  \u.(\v._);
M>  \z._;
M>  \P.(\v49.v49);
M>  \P.(\v54.v54);
M>  \w.w;
M>  _;
M>  <_,sj>;
M>  \x.(\v73.<1(v73),((((((term_of(Uord_in_dU)(_))(<_,<_,\d.(\v9.((((1(v9))(\x._))
M>  (\P.(\v4.v4)))(\u.u(\A.(\r.(\d._)))))(((2(v9))(_))(\v3.(\v4.v3))))>>))
M>  (x))(_))(_))(2(v73)))(sj)>);
M>  \x.(\y.(\v99.(\v100.(\v101.v101))));
M>  \x.(\v103.2(v103))]
M> : term list

M> d;;
M> term_of(Uord_in_dU) : term
M> (destruct_real_tuple o fixup o an o make_ap) [bpf0;'_';d];;
M> [_;
M>  \u.(\v._);
M>  \z._;
M>  _;
M>  \u.(\v._);
M>  \u._;
M>  \P.(\v133.v133);
M>  \P.(\v138.v138);
M>  \w.w;
M>  _;
M>  term_of(Uord_in_dU);
M>  \x.(\v153.1(v153));
M>  \x.(\y.(\v164.(\v165.(\v166.v166))));
M>  \x.(\v168.2(v168))]
M> : term list

Now we deal with p1n for n>0.

M> let [();p;s] = (destruct_tuple o an o make_ap) 
M>   [f1; '_'; make_tuple ['_';'_';'_';'_';'\P.\x.x';'_';' _';'opn';'bpfn']];;
M> p =  : term
M> s =  : term
M> let [r1;r2;r3] = un_ap s;;
M> r1 =  : term
M> r2 =  : term
M> r3 =  : term
M> r1;;
M> bpfn : term
M> r3;;
M> term_of(Uord_in_dU) : term

M> let [();();();();eq;();();op;bpf] = destruct_tuple p;;
M> eq =  : term
M> op =  : term
M> bpf =  : term
M> eq;;
M> \P.(\v23.v23) : term

M> let [op;();();();();p] = (un_ap o an o make_ap)
M>   [op;'_';'_';'_';'_';'sj'];; 
M> op =  : term
M> p =  : term
M> op;;
M> opn : term
M> (destruct_real_tuple o fixup) p;;
M> [_;
M>  \u.(\v._);
M>  \z._;
M>  _;
M>  \u.(\v._);
M>  \z._;
M>  \P.(\v49.v49);
M>  \P.(\v54.v54);
M>  \w.w;
M>  _;
M>  <_,sj>;
M>  \x@34.(\v73.<1(v73),((((((term_of(Uord_in_dU)(_))(<_,<_,\d.(\v9.((((1(v9))(\x._))
M>  (\P.(\v4.v4)))(\u.u(\A.(\r.(\d._)))))(((2(v9))(_))(\v3.(\v4.v3))))>>))(x@34))(_))
M>  (_))(2(v73)))(sj)>);
M>  \x.(\y.(\v99.(\v100.(\v101.v101))));
M>  \x@35.(\v103.2(v103))]
M> : term list

M> let [op;();();();();p] = (un_ap o an o make_ap) [bpf;'_';d];;
M> op =  : term
M> p =  : term
M> op;;
M> opn : term
M> (destruct_real_tuple o fixup) p;;
M> [_;
M>  \u.(\v._);
M>  \z._;
M>  _;
M>  \u.(\v._);
M>  \u._;
M>  \P.(\v133.v133);
M>  \P.(\v138.v138);
M>  \w.w;
M>  _;
M>  term_of(Uord_in_dU);
M>  \x.(\v153.1(v153));
M>  \x.(\y.(\v164.(\v165.(\v166.v166))));
M>  \x@42.(\v168.2(v168))]
M> : term list


Now for the second part of the looping analysis, where we examine the 
nth unrolling of YF.

First, we unroll.

M> let wf = 'term_of(Uord_wf)';;
M> wf = term_of(Uord_wf) : term
M> let [F;r] = (un_ap o bag_types o hn o make_ap) 
M>   [wf; '_'; make_tuple [make_tuple ['_';'pk0';d]; 'fk'] ];;
M> F =  : term
M> r =  : term
M> destruct_token F;;
M> `F` : tok
M> let t,u = destruct_apply r;;
M> t =  : term
M> u =  : term
M> let w,() = destruct_apply t;;
M> w =  : term
M> hr_until `Uord_wf` w;;
M>  : term
M> destruct_term_of_theorem it;;
M> `Uord_wf` : tok
M> let [t;f] = destruct_tuple (hn u);;
M> t =  : term
M> f =  : term

Now we make sure that t has the proper form.

M> let [a;();b;u;uu] = (un_ap o an) t;;
M> a =  : term
M> b =  : term
M> u =  : term
M> uu =  : term
M> a,b;;
M> fk,pk0 : (term # term)
M> let [();p;d] = (destruct_tuple o an o make_ap) 
M>   [make_tuple ['_';'pk1';s0]; u; uu];; 
M> p =  : term
M> d =  : term
M> d;;
M> term_of(Uord_in_dU) : term
M> (destruct_real_tuple o fixup) p;;
M> [_;
M>  _;
M>  _;
M>  \x.x;
M>  pk1;
M>  term_of(Uord_in_dU);
M>  \x.(\p.1(p));
M>  \x.(\y.(\p1.(\p2.(\p3.p3))));
M>  \x.(\p.2(p))]
M> : term list

Finally, we make check that f has the desired properties.

M> let r = pkn;;
M> r =  : term
M> (destruct_real_tuple o fixup) r;;
M> [_;
M>  _;
M>  _;
M>  ˆx. x;
M>  p;
M>  _;
M>  \x.(\p.1(p));
M>  ˆ x y. ˆ p1 p2 p3. p3;
M>  \x.(\p.2(p))]
M> : term list
M> let rr = substitute sn ['s','sn'];;
M> rr =  : term
M> (destruct_real_tuple o fixup) rr;;
M> [_;
M>  _;
M>  _;
M>  _;
M>  _;
M>  _;
M>  ˆP x. x;
M>  ˆP x. x;
M>  ˆx. x;
M>  _;
M>  <_,sn>;
M>  \x.(\p.<1(p),_>);
M>  ˆ x y. ˆ p1 p2 p3. p3;
M>  \x.(\p.2(p))]
M> : term list
M> let [a; ();b;u;uu] = (un_ap o an o make_ap) [f; '_'; r];;
M> a =  : term
M> b =  : term
M> u =  : term
M> uu =  : term
M> a,b;;
M> fk,p : (term # term)
M> let [();p;s] = (destruct_tuple o an o make_ap) 
M>   [make_tuple ['_';'q';rr]; u; uu];;
M> p =  : term
M> s =  : term
M> s;;
M> sn : term
M> (destruct_real_tuple o fixup) p;;
M> [_;
M>  _;
M>  _;
M>  \x.x;
M>  q;
M>  _;
M>  \x.(\v65.1(v65));
M>  \x.(\y.(\v74.(\v75.(\v76.v76))));
M>  \x.(\v92.2(v92))]
M> : term list
M> Runtime: 1992 ms



Following is the computation required for the second "no fixing"
half of the proof.

M> let wfp =  modify_wf (ext `Uord_wf`);;
M> wfp =  : term
M> pretty_print_term_to_file (wfp,
M> `Nuprl:Libraries;NewGirardsParadox;modified-wf.text`);; () : void
M> let [X;F;v] = (un_ap o hn o make_ap) [wfp; '_'; make_tuple
M> [make_tuple ['_';pk0;d]; '_']];; 
M> X =  : term
M> F =  : term
M> v =  : term
M> X;;
M> "X" : term
M> (fst o destruct_lambda) F;;
M> `v24` : tok
M> (fst o destruct_apply o snd o destruct_lambda) F;;
M> "F" : term
M> free_vars F;;
M> [p; _] : term list
M> free_vars v;;
M> [] : term list
_';pk0;d]; '_']];;X =  : te
rm
F =  : term
v =  : term
Runtime: 2251 ms

X;;"X" : term

(fst o destruct_lambda) F;;`v24` : tok

(fst o destruct_apply o snd o destruct_lambda) F;;"F" : term
free_vars F;;
[p; _] : term list
Runtime: 6411 ms
free_vars v;;
[] : term list
let [X;F;v] = (un_ap o hn o make_ap) [wfp; '_'; make_tuple ['_';'_';d]; '_']];;
non top level decln must have IN clause
|skipping:|] ] ;; PARSE failed      
let [X;F;v] = (un_ap o hn o make_ap) [wfp; '_'; make_tuple [make_tuple ['_';'pk0';d]; '_']];;
X =  : term
F =  : term
v =  : term
Runtime: 5994 ms
(fst o destruct_lambda) F;;
`v24` : tok
(fst o destruct_apply o snd o destruct_lambda) F;;
 : term
it;;
"F" : term
free_vars F;;
[pk0; _] : term list
Runtime: 1950 ms
free_vars v;;
[] : term list
